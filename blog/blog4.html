<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <style type="text/css">
    </style>
</head>

<body>
    <script src="./blog_top.js"></script>
    <br><br><br>
    <!--  Beginning of the blog  -->
    <h1 id="project_database">Database Design Project (C++)</h1>
    <h2 id="project0">Project 0</h2>
    <p>Linux_Ubuntu (VMWARE)<br />
        C++ Template template <typename T><br />
            CMake<br />
            Exception </p>
    <p>How to create m*n arrays [the 2nd way-inherit] </p>
    <p>Google C++ Style Guide<br />
        Naming_Class Data Members need a trailing underscore. </p>
    <p>** no viable conversion from<br />
        std::unique_ptr<bustub::RowMatrix<int> : temp<br />
            const RowMatrix<T> * : temp.get() </p>
    <p>Convert one int -&gt;int64<em>t
            const uint64</em>t size = (static<em>cast<uint64_t>(rows</em>) * cols_) </p>
    <p>Consider replacing 'unsigned long' with 'uint64' uint64_t </p>
    <p>//#ifndef _<em>int8</em>t_defined<br />
        //# define _<em>int8</em>t<em>defined
            typedef signed char int8</em>t;<br />
        typedef short int int16<em>t;
            typedef int int32</em>t;<br />
        //# if _<em>WORDSIZE == 64
            typedef long int int64</em>t;<br />
        //# else<br />
        _<em>extension</em>_<br />
        typedef long long int int64_t;<br />
        //# endif
        //#endif </p>
    <p>/* Unsigned. */<br />
        typedef unsigned char uint8<em>t;
            typedef unsigned short int uint16</em>t;<br />
        //#ifndef _<em>uint32</em>t<em>defined
            typedef unsigned int uint32</em>t;<br />
        //# define _<em>uint32</em>t_defined<br />
        //#endif<br />
        //#if _<em>WORDSIZE == 64
            typedef unsigned long int uint64</em>t;<br />
        //#else<br />
        _<em>extension</em>_
        typedef unsigned long long int uint64_t;<br />
        //#endif </p>
    <p>C-style casts are discouraged; use static<em>cast/const</em>cast/reinterpret_cast </p>
    <p>Use brace initialization to convert arithmetic types (e.g., int64_t{x}). This is the safest approach because code
        will not compile if conversion can result in information loss. The syntax is also concise. </p>
    <p>Use absl::implicit_cast to safely cast up a type hierarchy, e.g., casting a Foo* to a SuperclassOfFoo* or casting
        a Foo* to a const Foo*. C++ usually does this automatically but some situations need an explicit up-cast, such
        as use of the ?: operator. </p>
    <p>Use static_cast as the equivalent of a C-style cast that does value conversion, when you need to explicitly
        up-cast a pointer from a class to its superclass, or when you need to explicitly cast a pointer from a
        superclass to a subclass. In this last case, you must be sure your object is actually an instance of the
        subclass. </p>
    <p>Use const_cast to remove the const qualifier (see const). </p>
    <p>Use reinterpret<em>cast to do unsafe conversions of pointer types to and from integer and other pointer types,
            including void*. Use this only if you know what you are doing and you understand the aliasing issues. Also,
            consider the alternative absl::bit</em>cast. </p>
    <p>Use absl::bit<em>cast to interpret the raw bits of a value using a different type of the same size (a type pun),
            such as interpreting the bits of a double as int64</em>t. </p>




    <a href="https://github.com/PeterHUistyping/CMU15-445_Database_Project">See More on GitHub</a>
    <!--  End of the blog  -->
    <script src="./blog_footer.js"></script>
</body>

</html>