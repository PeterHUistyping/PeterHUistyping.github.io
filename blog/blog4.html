<html>

<head>
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <style type="text/css">
    </style>
    <body_>
        <div class="top">
            <ul>
                <li>
                    <a_ href="#"><I>Peter </I>HU's Website</a_>
                </li>
                <li>
                    <a href="../index.html">🏠HOME</a>
                </li>
                <li> <a href="../index.html#project">📊Project</a>
                    <ul>
                        <li> <a href="../index.html#ongoing_project">🆕Ongoing Project</a></li>
                        <li> <a href="../index.html#previous_project">📖Previous Project</a></li>
                    </ul>
                </li>
                <li><a href="https://github.com/PeterHUistyping">🖥️Github</a></li>
                <li><a href="../blog/blog.html">📝Blog</a></li>
                <li><a href="../index.html#contact">📬Contact</a></li>
                <li><a href="#">⬆️Top</a></li>
            </ul>
        </div>
    </body_>
</head>

<body>
    <br><br><br>
    <!--  Beginning of the blog  -->
    <h1 id="project_database">Database Design Project (C++)</h1>
    <h2 id="project0">Project 0</h2>
    <p>Linux_Ubuntu (VMWARE)<br />
        C++ Template template <typename T><br />
            CMake<br />
            Exception </p>
    <p>How to create m*n arrays [the 2nd way-inherit] </p>
    <p>Google C++ Style Guide<br />
        Naming_Class Data Members need a trailing underscore. </p>
    <p>** no viable conversion from<br />
        std::unique_ptr<bustub::RowMatrix<int> : temp<br />
            const RowMatrix<T> * : temp.get() </p>
    <p>Convert one int -&gt;int64<em>t
            const uint64</em>t size = (static<em>cast<uint64_t>(rows</em>) * cols_) </p>
    <p>Consider replacing 'unsigned long' with 'uint64' uint64_t </p>
    <p>//#ifndef _<em>int8</em>t_defined<br />
        //# define _<em>int8</em>t<em>defined
            typedef signed char int8</em>t;<br />
        typedef short int int16<em>t;
            typedef int int32</em>t;<br />
        //# if _<em>WORDSIZE == 64
            typedef long int int64</em>t;<br />
        //# else<br />
        _<em>extension</em>_<br />
        typedef long long int int64_t;<br />
        //# endif
        //#endif </p>
    <p>/* Unsigned. */<br />
        typedef unsigned char uint8<em>t;
            typedef unsigned short int uint16</em>t;<br />
        //#ifndef _<em>uint32</em>t<em>defined
            typedef unsigned int uint32</em>t;<br />
        //# define _<em>uint32</em>t_defined<br />
        //#endif<br />
        //#if _<em>WORDSIZE == 64
            typedef unsigned long int uint64</em>t;<br />
        //#else<br />
        _<em>extension</em>_
        typedef unsigned long long int uint64_t;<br />
        //#endif </p>
    <p>C-style casts are discouraged; use static<em>cast/const</em>cast/reinterpret_cast </p>
    <p>Use brace initialization to convert arithmetic types (e.g., int64_t{x}). This is the safest approach because code
        will not compile if conversion can result in information loss. The syntax is also concise. </p>
    <p>Use absl::implicit_cast to safely cast up a type hierarchy, e.g., casting a Foo* to a SuperclassOfFoo* or casting
        a Foo* to a const Foo*. C++ usually does this automatically but some situations need an explicit up-cast, such
        as use of the ?: operator. </p>
    <p>Use static_cast as the equivalent of a C-style cast that does value conversion, when you need to explicitly
        up-cast a pointer from a class to its superclass, or when you need to explicitly cast a pointer from a
        superclass to a subclass. In this last case, you must be sure your object is actually an instance of the
        subclass. </p>
    <p>Use const_cast to remove the const qualifier (see const). </p>
    <p>Use reinterpret<em>cast to do unsafe conversions of pointer types to and from integer and other pointer types,
            including void*. Use this only if you know what you are doing and you understand the aliasing issues. Also,
            consider the alternative absl::bit</em>cast. </p>
    <p>Use absl::bit<em>cast to interpret the raw bits of a value using a different type of the same size (a type pun),
            such as interpreting the bits of a double as int64</em>t. </p>




    <a href="https://github.com/PeterHUistyping/CMU15-445_Database_Project">See More on GitHub</a>
    <!--  End of the blog  -->
    <br><br><br><br><br>
    <div class=" blog">
        <ul>
            <li><a href="../index.html">⬅️Back to HOME🏠</a></li>
        </ul>
    </div>

    <HR style="border:1 dashed #987cb9" width="50%" color=#987cb9 SIZE=1>
    <table class="table_footer">
        <tbody>
            <td>
                Originally written in Markdown(.md). Convert Markdown to HTML via <a
                    href="https://showdownjs.com/">Showdown</a><br>
                © Copyright 2022 PeterHU. Hosted by <a href="https://pages.github.com/">GitHub Pages</a>.
                Last updated:
                <script>
                    document.write(document.lastModified);
                </script>
                </div>
            </td>
        </tbody>
    </table>
</body>

</html>